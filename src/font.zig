// 8x8 bitmap font (ASCII 0-127). Each byte = one row, MSB = leftmost pixel.
const glyph_table: [128][8]u8 = blk: {
    var t = [_][8]u8{[_]u8{0} ** 8} ** 128;

    t['A'] = .{ 0x3C, 0x42, 0x81, 0x81, 0xFF, 0x81, 0x81, 0x00 };
    t['B'] = .{ 0xFE, 0x81, 0x81, 0xFE, 0x81, 0x81, 0xFE, 0x00 };
    t['C'] = .{ 0x3C, 0x42, 0x80, 0x80, 0x80, 0x42, 0x3C, 0x00 };
    t['D'] = .{ 0xF8, 0x84, 0x82, 0x82, 0x82, 0x84, 0xF8, 0x00 };
    t['E'] = .{ 0xFE, 0x80, 0x80, 0xFC, 0x80, 0x80, 0xFE, 0x00 };
    t['F'] = .{ 0xFE, 0x80, 0x80, 0xFC, 0x80, 0x80, 0x80, 0x00 };
    t['G'] = .{ 0x3C, 0x42, 0x80, 0x8F, 0x81, 0x42, 0x3C, 0x00 };
    t['H'] = .{ 0x81, 0x81, 0x81, 0xFF, 0x81, 0x81, 0x81, 0x00 };
    t['I'] = .{ 0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00 };
    t['J'] = .{ 0x3E, 0x04, 0x04, 0x04, 0x84, 0x84, 0x78, 0x00 };
    t['K'] = .{ 0x84, 0x88, 0x90, 0xE0, 0x90, 0x88, 0x84, 0x00 };
    t['L'] = .{ 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xFE, 0x00 };
    t['M'] = .{ 0x81, 0xC3, 0xA5, 0x99, 0x81, 0x81, 0x81, 0x00 };
    t['N'] = .{ 0x81, 0xC1, 0xA1, 0x91, 0x89, 0x85, 0x83, 0x00 };
    t['O'] = .{ 0x3C, 0x42, 0x81, 0x81, 0x81, 0x42, 0x3C, 0x00 };
    t['P'] = .{ 0xFC, 0x82, 0x82, 0xFC, 0x80, 0x80, 0x80, 0x00 };
    t['Q'] = .{ 0x3C, 0x42, 0x81, 0x81, 0x89, 0x46, 0x3D, 0x00 };
    t['R'] = .{ 0xFC, 0x82, 0x82, 0xFC, 0x90, 0x88, 0x84, 0x00 };
    t['S'] = .{ 0x7C, 0x82, 0x80, 0x7C, 0x02, 0x82, 0x7C, 0x00 };
    t['T'] = .{ 0xFF, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00 };
    t['U'] = .{ 0x81, 0x81, 0x81, 0x81, 0x81, 0x42, 0x3C, 0x00 };
    t['V'] = .{ 0x81, 0x81, 0x81, 0x42, 0x42, 0x24, 0x18, 0x00 };
    t['W'] = .{ 0x81, 0x81, 0x81, 0x99, 0xA5, 0xC3, 0x81, 0x00 };
    t['X'] = .{ 0x81, 0x42, 0x24, 0x18, 0x24, 0x42, 0x81, 0x00 };
    t['Y'] = .{ 0x81, 0x42, 0x24, 0x18, 0x18, 0x18, 0x18, 0x00 };
    t['Z'] = .{ 0xFF, 0x02, 0x04, 0x18, 0x20, 0x40, 0xFF, 0x00 };

    break :blk t;
};

pub fn drawChar(
    buf: []u32,
    width: usize,
    height: usize,
    x: usize,
    y: usize,
    ch: u8,
    color: u32,
    scale: usize,
) void {
    const idx: usize = if (ch < 128) ch else 0;
    const glyph = glyph_table[idx];

    for (glyph, 0..) |row_bits, row| {
        var col: usize = 0;
        while (col < 8) : (col += 1) {
            // MSB = leftmost pixel
            const set = (row_bits >> @intCast(7 - col)) & 1;
            if (set == 0) continue;

            // Fill a scale√óscale block
            var dy: usize = 0;
            while (dy < scale) : (dy += 1) {
                var dx: usize = 0;
                while (dx < scale) : (dx += 1) {
                    const px = x + col * scale + dx;
                    const py = y + row * scale + dy;
                    if (px >= width or py >= height) continue;
                    buf[py * width + px] = color;
                }
            }
        }
    }
}

pub fn drawString(
    buf: []u32,
    width: usize,
    height: usize,
    x: usize,
    y: usize,
    text: []const u8,
    color: u32,
    scale: usize,
) void {
    const char_w = 8 * scale + scale; // glyph width + 1 pixel gap
    for (text, 0..) |ch, i| {
        drawChar(buf, width, height, x + i * char_w, y, ch, color, scale);
    }
}
